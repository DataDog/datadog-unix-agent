#!/bin/bash

YAML_BACKUP=
ETC_BACKUP=
PSUTIL_WHEEL=
AIX_VERSION=$(uname -v)
AIX_RELEASE=$(uname -r)

#Compares the two packages version number
function cmp_version() {
    large=$(echo  ${pkgcurr[1]} ${pkgversion[$index]}  | \
        awk '{ split($1, a, ".");
    split($2, b, ".");
    x = 0;
    for (i = 1; i <= 4; i++)
        if (a[i] < b[i]) {
            x = 3;
            break;
        } else if (a[i] > b[i]) {
        x = 2;
        break;
    }
    print x;
}')
return $large
}

#Compares the two packages release number
function cmp_release() {
    if [[ $1 < $2 ]]
    then
        return 3
    elif [[ $1 > $2 ]]
    then
        return 2
    elif [[ $1 == $2 ]]
    then
        return 1
    fi
}

function install_python() {
    #Check if some packages are already installed from the yum_bundle.
    
    cd $1/deps/rpms

    echo -e "\n"
    echo -e "Checking if any of the rpms are already installed...\n"
    pkgname=()
    pkgversion=()
    pkgrelease=()
    inst_list=()

    while read rpm_file
    do
        pkgname[${#pkgname[@]}]=`rpm -qp --qf "%{NAME}" $rpm_file`
        pkgversion[${#pkgversion[@]}]=`rpm -qp --qf "%{VERSION}" $rpm_file`
        pkgrelease[${#pkgrelease[@]}]=`rpm -qp --qf "%{RELEASE}" $rpm_file`
    done < <(ls *.rpm)

    let "index=0"
    for pk in ${pkgname[@]}
    do
        # We need to match exact package name, as we might have packages like python python-devel etc..
        # Packages name will be followed by the version number with "-" as a seperator.

        pkgcurr=("")
        let "flag=0"
        rpm_file=`ls *.rpm | grep  "^$pk-[0-9]"`
        line=`rpm -qa | grep "^$pk-[0-9]"`

        if [[ ! -z $line ]]
        then 
            # Special care must be taken for packages name having more than one fields.
            # For example python-devel
            oldIFS=$IFS
            IFS='-'
            name_ver=($line)
            IFS=$oldIFS
            count=`echo ${#name_ver[@]}` #Count number of fields in a package. 
            # Exclude release, version field plus array index starts with 0.
            let "i=$count-3"
        
            if [[ $i -eq 0 ]]
            then
                name=`echo "${name_ver[0]}"`
            elif [[ $i -eq 1 ]]
            then
                name=`echo "${name_ver[0]}-${name_ver[1]}"`
            elif [[ $i -eq 2 ]]
            then
                name=`echo "${name_ver[0]}-${name_ver[1]}-${name_ver[2]}"`
            elif [[ $i -eq 3 ]]
            then
                name=`echo "${name_ver[0]}-${name_ver[1]}-${name_ver[2]}-${name_ver[3]}"`
            else
                echo "Package name more than 4 fields"
            fi

            #To get version exclude release field plus 0 index array.
            let "j=$count-2"
            ver=`echo ${name_ver[$j]}`
         
            # Now set the name version field.
            pkgtest=($name $ver)
        elif [[ -z $line ]]
        then
            pkgtest=($line)
        fi

        #get the release field from the installed package.
        release=`rpm -qa | grep "^$pk-[0-9]" | awk -F '-' {'print $NF'} | awk -F '.' {'print $1'}`
        # If package from yum_bundle is installed.
        if [[ ${pkgtest[0]} == $pk ]]
        then
            pkgcurr=($name $ver)
            #compare versions of installed package & from the yum bundle.
            cmp_version ${pkgtest[1]} ${pkgversion[$index]}
            rc=$?
            if [[ $rc -eq 3 ]]
            then
                let "flag=3" #Lower version already installed
            elif [[ $rc -eq 2 ]]
            then
                let "flag=2" # Higher version already installed
            elif [[ $rc -eq 0 ]]
            then
                # If version numbers are same then compare the release of packages.
                if [[ ${pkgtest[1]} == ${pkgversion[$index]} ]]
                then
                    cmp_release $release ${pkgrelease[$index]}
                    rc=$?
                    if [[ $rc -eq 3 ]]
                    then
                        let "flag=3"
                    elif [[ $rc -eq 2 ]]
                    then
                        let "flag=2" 
                    elif [[ $rc -eq 1 ]]
                    then
                        let "flag=1"   # Exact version installed
                    fi
               fi
           fi
        fi
      
        if [[ "$flag" -eq 1 ]]
        then
            echo "Package ${pkgcurr[0]}-${pkgcurr[1]}-$release is already installed"
            let "index=index+1"
            continue;
        elif [[ "$flag" -eq 2 ]]
        then
            echo "Skipping ${pkgname[$index]}-${pkgversion[$index]}-${pkgrelease[$index]} as higher version is installed already."
            echo "Please make sure these packages are from toolbox as there is no gurantee that"
            echo "third party packages may be compatible with toolbox packages.\n"
            let "index=index+1"
            continue;
        elif [ "$flag" -eq 3 ]
        then
            echo "${pkgtest[0]}-${pkgtest[1]}-$release is installed. Will be updated to ${pkgname[$index]}-${pkgversion[$index]}-${pkgrelease[$index]} ...."
            inst_list[${#inst_list[*]}+1]=$rpm_file
            let "index=index+1"
            continue;	
        elif [ "$flag" -eq 0 ]
        then
            echo "${pkgname[$index]}-${pkgversion[$index]}-${pkgrelease[$index]} will be installed ...."
            inst_list[${#inst_list[*]}+1]=$rpm_file
            let "index=index+1"
            continue;
        fi
    done

    if [[ ${#inst_list[@]} -eq 0 ]]
    then
        echo "\nYum and all it's dependencies are installed already..."
        cd - >/dev/null 2>&1
        return 1
    fi

    echo -e "\nInstalling the packages.\n"
    rpm -Uvh ${inst_list[@]}

    if [[ $? -eq 0 ]]
    then
        echo "\033[1;32mYum installed Successfully.... \033[m"
    elif [[ $? -ne 0 ]]
    then
       echo "\033[1;31mYum installation failed... \033[m" 
       echo "If the failure was due space requirement then increase the /opt space and please retry"
       echo "Other reason of failure could be mixing of Toolbox packages and packages from other sources."
        cd - >/dev/null 2>&1
       return 1
    fi

    cd - >/dev/null 2>&1
}

function unpack() {
    echo "Unpacking..."
    gunzip ./archive.tar.gz
    tar xf ./archive.tar

    echo "Copying..."
    PARENT_DIR=$(dirname $1)
    mkdir -p $PARENT_DIR
    find . -type d -name 'DataDog-datadog-unix-agent*' 2>/dev/null | head -n 1 | xargs -t -I {} cp -R {} $1
}

function install() {
    cd $1

    set +e
    echo "preparing system-wide python..."
    echo -e "\tchecking for pip..."
    python -c "import pip" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo -e "\t\tpip unavailable - installing..."
        python $(cd $1; pwd)/deps/sys/get-pip.py --no-index --find-links=$(cd $1; pwd)/deps/sys/
    else
        echo "pip already installed, will use existing system pip"
    fi

    deps=("setuptools" "wheel" "virtualenv")
    for dep in "${deps[@]}"; do
        echo -e "\tchecking for $dep..."
        python -c "import $dep" >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo -e "\t\t$dep unavailable - installing..."
            python -m pip install --no-index --find-links file://$(cd $1; pwd)/deps/sys/ $dep 
        else
            echo "$dep already installed, will use existing system $dep"
        fi
    done

    set -e

    echo "building virtual environment from scratch..."
    python -m virtualenv --python python2.7 venv
    source ./venv/bin/activate

    echo "installing python dependencies..."
    pip install -r requirements.txt --no-index --find-links file://$(cd $1; pwd)/deps/env/

    echo "installing bundled (non-core) checks..."
    pip install -r requirements.txt --no-index --find-links file://$(cd $1; pwd)/deps/env/ $(cd $1; pwd)/checks/bundled/datadog_checks_base
    for check in $(ls -d $(cd $1; pwd)/checks/bundled/* | grep -iv 'datadog_checks_base');
    do
        echo "installing $(basename $check)..."
        pip install -r requirements.txt --no-index --find-links file://$(cd $1; pwd)/deps/env/ $check
    done
    cd - 


    echo "finalizing directory structure defaults..."
    mkdir -p $1/var/log/datadog
    mkdir -p $1/etc/datadog-agent/conf.d
}


echo "Installation for $AIX_VERSION.$AIX_RELEASE..."

# case "$AIX_VERSION" in
#     6|7) 
#         M=
#         python -c "import platform; print platform.architecture()[0]" | grep '64bit'
#         if [ $? -eq 0 ]; then
#             M='m'
#         fi
#         PSUTIL_WHEEL="psutil-5.4.6-cp27-cp27${M}-aix_${AIX_VERSION}_${AIX_RELEASE}.whl"
#         ;;
#     *) 
#         echo "unsupported AIX version: $AIX_VERSION.$AIX_RELEASE - bailing out"
#         exit 1
#         ;;
# esac


echo "Running Installer..."
if [ -e $1/datadog.yaml ]; then
    echo "existing configuration file found, backing up..."
    cp $1/datadog.yaml $TMPDIR 
fi

if [ -e $1/etc ]; then
    echo "existing configuration directory found, backing up..."
    cp -rf $1/etc  $TMPDIR
fi

if [ -d $1 ]; then
    echo "Previous installation found, it will be overwritten (existing configuration will be preserved however)."
    read -p "Are you sure you want to continue? " -n 1 -r
    echo 
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        rm -rf $1
    else
        echo "will not continue with installation, exiting..."
        exit 0
    fi
fi

unpack $1

which python >/dev/null 2>&1
if [ $? -ne 0 ];
then
    echo "install python via rpm..."
    install_python $1
    if [ $? -ne 0 ];
    then
        echo "problem installing python..."
        exit 1
    fi
fi

set -e

echo "setting up..."
install $1

if [ -e $TMPDIR/datadog.yaml ]; then
    echo "restoring previously found configuration file..."
    cp $TMPDIR/datadog.yaml $1/datadog.yaml
fi

if [ -e $TMPDIR/etc ]; then
    echo "restoring previously found configuration directory..."
    cp -rf $TMPDIR/etc $1/
fi

echo "Installation complete!"
